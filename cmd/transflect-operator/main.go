package main

import (
	"context"
	"fmt"
	"os"
	"os/signal"
	"syscall"

	"github.com/alecthomas/kong"
	"github.com/cashapp/transflect/pkg/transflect"
	"github.com/pkg/errors"
	"github.com/rs/zerolog"
	"github.com/rs/zerolog/log"
	"github.com/rs/zerolog/pkgerrors"
	"golang.org/x/sync/errgroup"
	"k8s.io/client-go/util/workqueue"
)

var (
	version   = "v0.0.0"
	errSignal = fmt.Errorf("received shutdown signal")
)

type config struct {
	UseIngress     bool             `short:"i" help:"Create and use temporary ingress to access temporary service, e.g. from outside cluster"`
	Address        string           `short:"a" help:"gRPC reflection server address, host:port"`
	Plaintext      bool             `short:"p" help:"Use plain-text; no TLS"`
	LeaseNamespace string           `help:"Namespace in which leader election lease is created" default:"transflect" env:"LEASE_NAMESPACE"`
	LeaseID        string           `help:"Unique ID for lease, UUID generated by default" env:"LEASE_ID"`
	LogFormat      string           `help:"Log format ('json', 'std')" enum:"json,std" default:"std"`
	Version        kong.VersionFlag `short:"v" help:"Print version information"`

	ProbesPort  string `help:"Probes server port" env:"PROBES_PORT" default:":8080"`
	MetricsPort string `help:"Metrics server port" env:"METRICS_PORT" default:":9090"`
}

func main() {
	cfg := &config{}
	_ = kong.Parse(cfg, kong.Vars{"version": version})

	if err := run(cfg); err != nil {
		log.Error().Stack().Err(err).Msg("exiting")
		os.Exit(1)
	}
}

func run(cfg *config) error {
	setupLogging(cfg)
	workqueue.SetProvider(&metricsProvider{})

	// create servers
	probes := newProbesServer(cfg.ProbesPort)
	metrics := newMetricsServer(cfg.MetricsPort)
	operator, err := newOperator(cfg)
	if err != nil {
		return err
	}

	// start servers
	g, ctx := errgroup.WithContext(context.Background())
	g.Go(func() error { return probes.start(ctx) })
	g.Go(func() error { return metrics.start(ctx) })
	g.Go(func() error { return operator.start(ctx) })
	g.Go(func() error { return handleSignals(ctx) })

	// shutdown
	err = g.Wait()
	if err != nil && !errors.Is(err, errSignal) {
		log.Error().Err(err).Msg("Error causing shutdown")
	}
	log.Debug().Msg("Shutdown done")

	return nil
}

func handleSignals(ctx context.Context) error {
	// handle graceful shutdown
	c := make(chan os.Signal, 1)
	signal.Notify(c, syscall.SIGINT, syscall.SIGTERM) // Use SIGQUIT (ctrl+\) for instant shutdown
	select {
	case <-ctx.Done():
		return nil
	case sig := <-c:
		log.Debug().Str("signal", sig.String()).Msg("Received signal, shutting down")
		return errSignal
	}
}

func setupLogging(cfg *config) {
	log.Logger = log.Output(os.Stdout)
	if cfg.LogFormat == "std" {
		log.Logger = log.Output(zerolog.ConsoleWriter{Out: os.Stdout})
	}
	zerolog.ErrorStackMarshaler = pkgerrors.MarshalStack
	transflect.LogAttempt = logAttempt
}

type ctxKey string

const ctxReplicaKey = ctxKey("replica")

func logAttempt(ctx context.Context, attempt int, err error) {
	replica := "unknown"
	if v := ctx.Value(ctxReplicaKey); v != nil {
		if s, ok := v.(string); ok {
			replica = s
		}
	}
	log.Error().Int("attempt", attempt).Err(err).Str("replica", replica).Msg("Reflection call error")
}
